# 정렬 알고리즘 종류 정리

## 🔹 1. 버블 정렬 (Bubble Sort)
- **아이디어**: 인접한 두 수를 비교해 큰 값을 뒤로 보내는 방식
- **시간 복잡도**: O(n²)
- **장점**: 구현이 매우 간단함
- **단점**: 비효율적, 느림

---

## 🔹 2. 선택 정렬 (Selection Sort)
- **아이디어**: 매번 가장 작은(또는 큰) 값을 찾아 맨 앞에 위치시킴
- **시간 복잡도**: O(n²)
- **장점**: 구현 간단, 메모리 적게 사용
- **단점**: 느림, 비교 횟수 많음

---

## 🔹 3. 삽입 정렬 (Insertion Sort)
- **아이디어**: 정렬된 부분에 데이터를 하나씩 삽입
- **시간 복잡도**: O(n²), 정렬되어 있을수록 빠름
- **장점**: 정렬된 데이터에 강함, 안정 정렬
- **단점**: 많은 데이터에는 느림

---

## 🔹 4. 병합 정렬 (Merge Sort)
- **아이디어**: 리스트를 반으로 나누고 정렬한 후 병합
- **시간 복잡도**: O(n log n)
- **장점**: 안정 정렬, 일관된 성능
- **단점**: 추가 메모리 공간 필요

---

## 🔹 5. 퀵 정렬 (Quick Sort)
- **아이디어**: 기준값(pivot)을 기준으로 작은 값과 큰 값으로 분할 정렬
- **시간 복잡도**: 평균 O(n log n), 최악 O(n²)
- **장점**: 매우 빠름, 실무에서 자주 사용
- **단점**: 최악의 경우 느림 (ex. 이미 정렬된 경우)

---

## 🔹 6. 힙 정렬 (Heap Sort)
- **아이디어**: 힙 자료구조를 이용해 정렬
- **시간 복잡도**: O(n log n)
- **장점**: 추가 메모리 적고 성능 일정
- **단점**: 구현 복잡, 안정 정렬 아님

---

## ✅ 간단 비교 표

| 알고리즘      | 평균 시간 복잡도 | 공간 복잡도 | 안정 정렬 | 구현 난이도 |
|---------------|------------------|--------------|-----------|--------------|
| 버블 정렬     | O(n²)            | O(1)         | ✅        | 아주 쉬움     |
| 선택 정렬     | O(n²)            | O(1)         | ❌        | 쉬움          |
| 삽입 정렬     | O(n²)            | O(1)         | ✅        | 쉬움          |
| 병합 정렬     | O(n log n)       | O(n)         | ✅        | 보통          |
| 퀵 정렬       | O(n log n)       | O(log n)     | ❌        | 보통~어려움   |
| 힙 정렬       | O(n log n)       | O(1)         | ❌        | 보통          |

---